<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
<button class="add">添加元素</button>
<div class="show">
  <!-- show标签 -->
  <h5>h5标签</h5>
  <p>p标签</p>
  <span>span标签</span>
  <div>div标签</div>
</div>

<script>
var add = document.querySelector('.add')
var show = document.querySelector('.show')

/* var tags = show.children
add.onclick = function (){
  var em = document.createElement('em')//动态元素/未来元素
  em.innerText = 'em标签 '
  show.appendChild(em)
  tags = show.children//重新获取所有子元素
  for (var i = 0, len = tags.length; i < len; i++){
    // 给所有子元素添加事件，包含动态元素/未来元素
    tags[i].onclick = function (){
      this.style.color = 'red'
    }
  }
}
for (var i = 0, len = tags.length; i < len; i++){
  // 给所有子元素添加事件，不包含动态元素/未来元素
  tags[i].onclick = function (){
    this.style.color = 'red'
  }
} */


// 事件委托：子元素的事件委托的父元素来完成
// 原理：事件冒泡
// 1.嵌套关系
// 2.有相同的事件
// 优势：
// 1.减少使用for循环 
// 2.运行效率更高 
// 3.减少事件注册，占用更少的内容
// 4.未来元素也可以添加事件

document.body.onclick = function(ev){
  // this -> show
  var e = ev || event//事件对象
  var target = e.target || e.srcElement//事件源
  
  // if (target.className !== 'add'){
  //   target.style.color = 'red'
  // }

  if (target.tagName == 'DIV'){
    target.style.color = 'red'
  }
  if (target.tagName == 'H5'){
    target.style.color = 'blue'
  }
  if (target.tagName == 'SPAN'){
    target.style.color = 'green'
  }
  if (target.tagName == 'P'){
    target.style.color = 'orange'
  }
  if (target.tagName == 'EM'){
    target.style.color = 'yellow'
  }

  if (target.className === 'add'){
    var em = document.createElement('em')//动态元素/未来元素
    em.innerText = 'em标签 '
    show.appendChild(em)
  }
}


</script>
</body>
</html>