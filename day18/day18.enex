<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20210110T074455Z" application="Evernote/Windows" version="6.x">
<note><title>day18</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">ES6常用API</span></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">let与const</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">let关键字，用来声明变量，它的用法类似于var。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let不允许重复声明变量；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(a);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(b);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let声明变量仅在块级作用域内有效；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var i = 0; i &lt; 10; i++) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(i);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(i);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (let v = 0; v &lt; 10; v++) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(v);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(v);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">不能通过let声明和形参相同的变量；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function test(a) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;let a = 123;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(a);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">test(456);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let声明变量不会提升；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(a);&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 2;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(b);&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意：let声明的变量一定要在声明之后使用，否则报错。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">暂时性死区TDZ</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6规定在某个区块中， 一旦用let或const声明一个变量，那么这个区块就变成块级作用域，用let或const声明的变量就“绑定”这个区域，不再受外部的影响。 在该变量声明之前不可以用，在语法上我们叫这种情况为：暂时性死区 (temporal dead</span> <span style="font-size: 14pt; font-family: 微软雅黑;">zone，简称 TDZ)。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var v = 1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">if (true) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(v);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;var v = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(v);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">上面代码中，存在全局变量v，但是块级作用域内let又声明了一个局部变量v，导致后者绑定这个块级作用域，所以在let声明变量之前，使用v会报错。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">let应用：改造选项卡效果</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">const关键字，用来声明一个只读的常量。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">const与let类似，</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">但是，const常量一旦声明，常量将不能重新赋值！</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const AGE = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(AGE);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">AGE = 20;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(AGE);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">意味着，const一旦声明，就必须立即初始化，不能留到以后赋值！</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const AGE;</span></div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0); font-size: 14pt; font-family: 微软雅黑;">本质：</span><span style="color: rgb(227, 0, 0); font-size: 14pt; font-family: 微软雅黑;">const实际上保证的，并不是值不能改变，而是指向的那个内存地址不能改变。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const FOO = {name: &apos;xm&apos;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">FOO.age = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(FOO.age);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">FOO = {name: &apos;xh&apos;};</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意：为了和变量区分，一般常量用大写字母。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">如：</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const PI = 3.14;</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">arrow functions(箭头函数)</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">定义：( 形参 ) =&gt; { 函数体 }</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = function () {</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ES5</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = () =&gt; {</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ES6</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">用箭头函数来写比原来的function写法要简洁很多（针对匿名函数使用）。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var reflect = function (value){</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//ES5</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;return value;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let reflect = value =&gt; value;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//ES6</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">箭头函数与传统的JavaScript函数主要区别在于以下几点：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">1.对 this 的关联。函数内部的 this 指向，取决于箭头函数定义的位置，而非箭头函数的调用对象。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var name = &apos;xh&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;name: &apos;xm&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;say: () =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;alert(this.name);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj.say();</span></div><div><br/></div><div><span style="font-family: 微软雅黑; font-size: 14pt;">当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，</span><span style="font-family: 微软雅黑; font-size: 14pt; color: rgb(227, 0, 0);">实际原因是箭头函数根本没有自己的this，它的this是继承外面</span><span style="font-family: 微软雅黑; font-size: 14pt; color: rgb(227, 0, 0);">的，因此内部的this就是外层代码块的this。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = function () {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;setTimeout(() =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;},2000);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">2.new 不可用。箭头函数不能使用 new 关键字来实例化对象，不然会报错。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var Test = function () {};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = new Test();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var Test = () =&gt; {};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = new Test();</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//Test is not a constructor</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">3.this 不可变。函数内部 this 不可变，在函数体内整个执行环境中为常量。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;name: &apos;隔壁王叔叔&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;age: 33</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">setTimeout(() =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}.bind(obj1),1000);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//报错</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">4.没有arguments对象。更不能通过arguments对象访问传入参数。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn(){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[0]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[1]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(1,2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var fn = () =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[0]);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//报错</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(3);</span></div></div><div><span style="font-size: 14pt;">&nbsp;</span></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">template string(（字符串模板）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6中字符串模板使用反引号 ` ` 表示，字符串模板中可以解析变量和函数，使用</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">${ }</span> <span style="font-size: 14pt; font-family: 微软雅黑;">解析</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var sname = &quot;小错&quot;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fnAge(){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;return 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var str = `大家好，我叫${sname},我今年${fnAge()}岁了`;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert( str );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">字符串模板非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var val1 = 11, val2 = 22, val3 = 33;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = &apos;&lt;ul&gt;&lt;li&gt;&apos;+val1+&apos;&lt;/li&gt;&lt;li&gt;&apos;+val2+&apos;&lt;/li&gt;&lt;li&gt;&apos;+val3+&apos;&lt;/li&gt;&lt;/ul&gt;&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = &apos;&lt;ul&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val1+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val2+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val3+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;/ul&gt;&apos;;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">使用ES6字符串模板：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = `</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&lt;ul&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val1}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val2}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val3}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&lt;/ul&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">`;</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Destructuring（解构赋值）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">解构赋值：解析结构进行赋值。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var x = 10 , y = 20 , z = 30;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var cat = &apos;ken&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var dog = &apos;lili&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var zoo = {cat: cat, dog: dog};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(zoo);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">用ES6完全可以像下面这么写：</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var [x,y,z] = [10,20,30];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var {sname,age} = {age : 10, sname : &quot;xm&quot; }</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( sname );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( age );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let cat = &apos;ken&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let dog = &apos;lili&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let zoo = {cat, dog};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(zoo);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">反过来可以这么写：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let dog = {type: &apos;animal&apos;, many: 2};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let { type, many} = dog;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(type);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(many);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">解构赋值可以作用在函数的参数上，让函数参数的值传递顺序改变</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn( {sname,age} ){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">return `大家好我叫${sname}，我今年${age}岁了`;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="color: rgb(45, 79, 201); font-size: 14pt; font-family: 微软雅黑;">console.log( fn( {age:23,sname:&quot;jack&quot;} ) );</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">函数的默认参数</span></div><div><span style="font-size: 10pt;">&nbsp;</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 基本用法</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function first(x = 1, y = 2) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&quot;x：&quot;+x ,&quot;y：&quot;+ y);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">first();&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:1 y:2&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">first(100);&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:100 y:2&apos;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 与解构赋值结合</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function second({x, y = 2}) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&quot;x：&quot;+x ,&quot;y：&quot;+ y);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">second({});</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:undefined y:2&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">second({x:100});&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:100 y:2&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">second({x:100,y:200});</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:100 y:200&apos;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 这种写法在传入多个形参时可以不按顺序写入，会方便很多，但有个问题，</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 没有默认值时，每次都要传“{}”就会显得很麻烦，于是我们可以再设置一次默认值。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 双重默认值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function third({x = 1 ,y = 2} = {}) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&quot;x：&quot;+x ,&quot;y：&quot;+ y);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">third();</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:1 y:2&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">third({x:100,y:200});</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:100 y:200&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">third({x:100});</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;x:100 y:2&apos;</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">includes()方法</span></div><div><span style="font-size: 10pt;">&nbsp;</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">数组的 includes() 方法用来判断一个数组是否包含一个指定的值，</span><span style="font-size: 14pt; font-family: 微软雅黑;">返回布尔值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">arr.includes(value,index);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">value 要查找的元素值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">index&nbsp;从 index 索引处开始查找 value，默认为 0，可选</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">字符串的 includes() 方法用于判断一个字符串是否包含</span><span style="font-size: 14pt; font-family: 微软雅黑;">一个指定的值</span><span style="font-size: 14pt; font-family: 微软雅黑;">，返回布尔值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">str.includes(searchString,index);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">searchString&nbsp;要搜索的字符串</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">index&nbsp;从 index 索引处开始搜索searchString ，默认为 0，可选</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Array.from( )</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">Array.from：将含有length属性，以数字为key的对象、类数组转成真正的数组。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Array.from(obj, map函数);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">第一个参数为要转换的对象，第二个参数为一个函数，可选，类似map函数。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">map函数 : 遍历数组--操作数组--返回数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3,4,5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var newArr = arr.map( (item) =&gt; { return item*2 } );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( newArr );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">类数组元素集合：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var lis = document.getElementsByTagName(&quot;li&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis.push(&apos;abc&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">将lis集合（类数组）转成 数组：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis = Array.from(lis);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( lis )</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis.push(&apos;abc&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">将对象转成 数组：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;0&quot; : 10 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;1&quot; : 20 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;2&quot; : 30 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;length&quot; : 3</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = Array.from( obj );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( arr );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">第二个参数是一个匿名函数 实现的是map功能：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var newArr = Array.from( obj , (item) =&gt; { return item*2; } )</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( newArr );</span></div></div><div><br/></div><div><br/></div><div>findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</div><div><br/></div><div>findIndex() 方法为数组中的每个元素都调用一次函数执行：</div><div><br/></div><div>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</div><div>如果没有符合条件的元素返回 -1</div><div>注意: findIndex() 对于空数组，函数是不会执行的。</div><div><br/></div><div>注意: findIndex() 并没有改变数组的原始值。</div><div>返回值：&nbsp;&nbsp;&nbsp;&nbsp;返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。</div><div>JavaScript 版本:&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 6</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">三个点（...）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">扩展运算符</span><span style="font-size: 14pt; font-family: 微软雅黑;">用三个点号表示，其功能是把数组或类数组对</span><span style="font-size: 14pt; font-family: 微软雅黑;">象（部署了iterator接口）</span><span style="font-size: 14pt; font-family: 微软雅黑;">展开成一系列用逗号隔开的参数序列。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(...[1, 2, 3]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(1, ...[2, 3, 4], 5);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var lis = document.getElementsByTagName(&quot;li&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log([...lis]);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">其他用法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr1 = [1,2];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr2 = [3,4,5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function addItems(arr, ...items) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;arr.push(...items);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">addItems(arr1,...arr2);</span> <span style="font-size: 14pt; color: rgb(168, 168, 168); font-family: 微软雅黑;">//&nbsp; =&gt;&nbsp;&nbsp;</span><span style="font-size: 14pt; color: rgb(168, 168, 168);">addItems(arr1,3,4,5);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(arr1);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">arr.push(...items) 和 addItems(arr1,...arr2) 函数调用都使用了扩展运算符将数组变为参数序列</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意这行：function addItems(arr, ...items) 这里的三个点并不是扩展运算符，而是 rest运算符</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">rest运算符</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">也</span><span style="font-size: 14pt; font-family: 微软雅黑;">是三个点，其功能与扩展运算符恰好相反，把逗号隔开的参数序列组合成一个数组</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn(...args) {</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// rest运算符 组合数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(args);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(...arr);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 扩展运算符 展开数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(...arr);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">展开对象：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = {name:&apos;xiaoming&apos;,sex:&apos;男&apos;,aeg:23};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj2 = {...obj1};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj2);&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// {name:&apos;xiaoming&apos;,sex:&apos;男&apos;,aeg:23}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var {name,...other} = obj1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(name);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;xiaoming&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(other);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// {sex: &quot;男&quot;, aeg: 23}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 注意：展开对象需要在{}中使用，不能直接使用...</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( ...obj1 );</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 报错</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Set 和 Map</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6 提供了两种新的数据结构 Set 和 Map。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Set</span> <span style="font-size: 14pt; font-family: 微软雅黑;">是一个构造函数，用来生成 Set 数据结构，它类似于数组，但是</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">成员的值都是唯一的、没有重复的</span><span style="font-size: 14pt; font-family: 微软雅黑;">， 初始化 Set 可以接受一个数组或类数组对象作为参数，也可以创建一个空的 Set：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s1 = new Set();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s2 = new Set([1, 2, 3]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">在 Set 中成员的值是唯一的，重复的值自动被过滤掉</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s1 = new Set([1, 2, 2, 3, 1, 4]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s1);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">Set 的一些属性方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">size：返回成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">add(value)：添加某个值，返回Set结构本身</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">has(value)：返回一个布尔值，表示该值是否为Set的成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">clear()：清除所有成员，没有返回值</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([1,2]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.add(3);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 添加成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.size);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 3 成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(3) {1, 2, 3}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.add([4,5]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 添加成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.size);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 4 成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.has(2));</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 有该成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(4) {1, 2, 3, [4, 5]}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.delete(2);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 删除成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(3) {1, 3, [4, 5]}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.has(2));</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false 没有该成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.clear();</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 清除所有成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(0) {}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">得益于数据结构 Set 查找更快速高效，但也因为数据结构的内部数据是无序的，无法实现按下标改查，排序等操作</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3,&apos;a&apos;,4,&apos;b&apos;];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set(arr);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set[0]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// undefined</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set[&apos;a&apos;]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// undefined</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Set 没有类似 getter 的方法，怎么取值呢？</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">可以遍历取值，或者可以把 Set 转成真正的数组！</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s5 = new Set([4,5,6,7,8]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var [a,b,c] = [...s5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(a);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(b);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(c);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [...s5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(arr[0]);</span></div><div><br/></div><div><span style="font-family: 微软雅黑; font-size: 14pt;">遍历 Set 对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.forEach((val,key,set)=&gt;{</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;val: &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;key: &apos;+key);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(set);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">});</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">使用ES6的 for of 遍历（数组，类数组，字符串，Set，Map）</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (const val of set) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(255, 0, 0);">for/of 与 for/in</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">for/of：遍历值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [4,5,6,7];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var val of arr) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(val);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//4 5 6 7</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">for/in：遍历键</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [4,5,6,7];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var key in arr) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(key);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//0 1 2 3</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var str = &apos;javascript&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var val of str) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Map</span> <span style="font-size: 14pt; font-family: 微软雅黑;">是一个构造函数，用来生成 Map 数据结构，它类似于对象，也是键值对的集合，但是“键”可以是非字符串， 初始化 Map 需要一个二维数组，或者直接初始化一个空的 Map：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var m1 = new Map();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var m2 = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(m1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(m2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Map 的一些操作方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">set(key, value)：设置键值对</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">get(key)：获取键对应的值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">has(key)：是否存在某个键</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">delete(key)：删除某个键值对，返回一个布尔值，表示删除是否成功</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.set(&apos;c&apos;,789);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map.get(&apos;c&apos;));</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 789</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map.has(&apos;b&apos;));</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 此key存在</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.delete(3);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 成功删除key</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Map(3) {&quot;a&quot; =&gt; 123, &quot;b&quot; =&gt; 456, &quot;c&quot; =&gt; 789}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">遍历 Map 对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;],[&apos;c&apos;, 789]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.forEach((val,key,obj)=&gt;{</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;val: &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;key: &apos;+key);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(obj);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">});</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">当然也可以使用ES6的 for of 遍历</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;],[&apos;c&apos;, 789]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (const item of map) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log( item );</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (const [key,val] of map) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(key+&apos; : &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">传统 Object 用字符串作键，Object 结构提供了“字符串 — 值”的对应</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Map 结构提供了“值 — 值”的对应，是一种更完善的 Hash 结构实现</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">如果你需要“键值对”的数据结构，Map 比 Object 更快速 更高效 更合适。</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Symbol类型</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Symbol 是 JavaScript 语言的第七种数据类型。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">在创建symbol类型数据时的参数只是作为标识使用，直接使用 Symbol() 也是可以的。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let s = Symbol(&apos;xm&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( s );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( typeof s</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var xm = Symbol();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;[xm] : &quot;小明&quot;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//对象的属性是Symbol类型</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Symbol类型的属性 取值是 必须 obj[xm] 不能用obj.xm</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( obj[xm] );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s4 = Symbol();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&apos;name&apos;: &apos;xm&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;[s4]: &apos;xh&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;[Symbol(&apos;age&apos;)]: 18</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj);&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// {name: &quot;xm&quot;, Symbol(): &quot;xh&quot;, Symbol(age): 18}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj.name);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// xm</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj[s4]);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// xh 访问对象的Symbol属性的值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj[Symbol(&apos;age&apos;)]);&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// undefined</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">修改symbol类型的属性</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj[xm] = &quot;web前端&quot;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( obj[xm] );</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">对象的Symbol属性不会被遍历出来（可以用来保护对象的某个属性）</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;sname&quot;:&quot;小明&quot;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;skill&quot; : &quot;web&quot;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var age = Symbol();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj[age] = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( obj );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for( var key in obj ){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(key + &quot; -&gt; &quot; + obj[key] );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">for/in&nbsp; &nbsp;Object.keys()&nbsp; &nbsp;Object.getOwnPropertyNames()&nbsp;&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">以及 JSON.stringify&nbsp; 等操作，不会访问到对象的 Symbol 属性</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let id = Symbol(&quot;id&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;[id]: &apos;007&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp; &nbsp; [Symbol(&apos;name&apos;)]: &apos;xiaocuo&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let arr = Object.getOwnPropertySymbols(obj);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(arr);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//[S</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">ymbol(id),Symbol(name)]</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj[arr[1]]);&nbsp;&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//&apos;xiaocuo&apos;&nbsp; 访问对象的Symbol属性的值</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let s1 = Symbol(&apos;name&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let s2 = Symbol(&apos;name&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( s1 === s2 );&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">官方提供了全局注册并登记的方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name1 = Symbol.for(&apos;name&apos;);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//检测到未创建后新建&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name2 = Symbol.for(&apos;name&apos;);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//检测到已创建后返回&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(name1 === name2);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj2 = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;age: 17,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;[name1]: &apos;xm&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj2[name1]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//&apos;xm&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj2[name2]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//&apos;xm&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj2[Symbol(&apos;name&apos;)]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//undefined</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj2[Symbol.for(&apos;name&apos;)]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//&apos;xm&apos;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">通过symbol对象获取到参数值：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name1 = Symbol.for(&apos;name1&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name2 = Symbol.for(&apos;name2&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(Symbol.keyFor(name1));&nbsp;&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;name1&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(Symbol.keyFor(name2));</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;name2&apos;</span></div><div><br/></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Object扩展</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.getOwnPropertySymbols(obj)&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">方法会返回当前对象的所有 Symbol 属性，返回数组</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.setPrototypeOf(obj1,obj2)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">方法用来设置一个对象的 prototype 对象，与Object.getPrototypeOf 方法配套</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">es5 实现原型链接</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = Object.create(obj2);</span><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 创建一个空对象,并把该对象的原型链接到obj2对象</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">es6 实现原型链接</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">Object.setPrototypeOf(obj1,obj2);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 把对象obj1的原型链接到obj2</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object. getOwnPropertyDescriptors(obj)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">获取指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj2 = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;name: &apos;xm&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;age: 23</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var attrObj1 = Object.getOwnPropertyDescriptor(obj2,&apos;name&apos;);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ES5获取一个属性的描述符</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var attrObj2 = Object. getOwnPropertyDescriptors(obj2);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 获取所有自身属性的描述符</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(attrObj1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(attrObj2);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">{</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">&nbsp; &nbsp; configable: true,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">&nbsp; &nbsp; enumerable: true,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">&nbsp; &nbsp; writeable: true,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">&nbsp; &nbsp; value: &apos;xm&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">}</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.values(obj)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">方法返回一个数组，成员是参数对象自身的所有可枚举属性的值（与Object.keys配套）</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = { foo: &apos;abc&apos;, baz: 123 };</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(Object.values(obj));</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.entries(obj)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const obj = { foo: &apos;bar&apos;, baz: 42 };</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">Object.entries(obj); // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.entries方法可以将对象转为真正的Map结构</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const obj = { foo: &apos;bar&apos;, baz: 42 };</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const map = new Map(Object.entries(obj));</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Map { foo: &quot;bar&quot;, baz: 42 }</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.assign(target,source)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = {a: 1, b: 2, c: {d: 4, e: 5}};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj2 = Object.assign({}, obj1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj1.c === obj2.c);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ture</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Object.assign 方法是一种对象浅拷贝，如果对象属性是引用类型，只能是拷贝引用地址</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">对象深拷贝</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = {a: 1, b: 2, c: {d: 4, e: 5}};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj2 = JSON.parse(JSON.stringify(obj1));</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj1.c === obj2.c);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">jQuery.extend(boolean,target,source);</span></div><div><br/></div><div><br/></div><div><a href="http://object.is/" style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Object.is</a><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">(val1,val2)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">方法用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">不同之处只有两个：一是: +0不等于-0，二是: NaN等于自身。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">+0 === -0</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//true</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">NaN === NaN</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">{} === {}</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><a href="http://object.is/" style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">Object.is</a><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">({}, {});</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><br/></div><div><a href="http://object.is/" style="color: rgb(168, 168, 168); font-size: 14pt; font-family: 微软雅黑;">Object.is</a><span style="color: rgb(227, 0, 0); font-size: 14pt; font-family: 微软雅黑;">(+0, -0)</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false</span></div><div><a href="http://object.is/" style="color: rgb(168, 168, 168); font-size: 14pt; font-family: 微软雅黑;">Object.is</a><span style="color: rgb(227, 0, 0); font-size: 14pt; font-family: 微软雅黑;">(NaN, NaN)</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(227, 0, 0); font-weight: bold;">ES6 类与继承</span></div><div><br/></div><div><span style="font-size: 14pt;">ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。</span></div><div><span style="font-size: 14pt;">新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</span></div><div><span style="font-size: 14pt;">无需考虑ES5中令人头疼的几个部分：构造函数、原型、继承...</span></div><div><br/></div><div><span style="font-size: 14pt;">用class定义一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。</span></div><div><br/></div><div><span style="font-size: 14pt;">class之间可以通过extends关键字实现继承，这比ES5通过修改原型链实现继承，要清晰和方便很多。</span></div><div><br/></div><div><span style="font-size: 14pt;">super关键字，它指向父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</span></div><div><br/></div><div><span style="font-size: 14pt;">ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造</span><span style="font-size: 14pt;">函数修改this。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">// es6类与继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">class Cat {</span></div><div><span style="font-family: 微软雅黑; color: rgb(54, 101, 238); font-size: 14pt;">&nbsp; &nbsp; abc = 78</span><span style="font-family: 微软雅黑; color: rgb(54, 101, 238); font-size: 14pt;">9;&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;constructor(n,c){&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 构造器 this指向实例对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = n;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = c;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.trait = function () {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&apos;卖萌~&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;skill(){&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 原型上的方法</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&apos;抓老鼠&apos;); // this指向实例对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp; &nbsp;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(222, 87, 0);">static</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">speak(){</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 静态方法 Cat.speak()</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; alert(&apos;喵&apos;); // this指向Cat</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp; &nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp; &nbsp;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(222, 87, 0);">static</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">type = &apos;动物&apos;;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 静态属性 Cat.type</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">class Dog extends Cat {&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;constructor(n,c,f){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(n,c);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 构造函数继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(54, 101, 238); font-size: 14pt; font-family: 微软雅黑;">&nbsp;this.food = f;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// super.skill();//supe能访问父类的方法(函数)</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// console.log(super.abc);//不能访问父类的属性</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// console.log(this.abc);//789</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// this.skill();//&apos;抓老鼠&apos;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// console.log(super);报错，不能直接访问super</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">var dog1 = new Dog(&apos;大黄&apos;,&apos;黑色&apos;,&apos;shi&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">dog1.trait();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">dog1.skill();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.name );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.color );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( dog1.food );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( dog1.mm );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.constructor );&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Dog</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></en-note>]]></content><created>20210110T062319Z</created><updated>20210110T065916Z</updated><note-attributes><author>陶舒健</author><source>desktop.win</source><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
